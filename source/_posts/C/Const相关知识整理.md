---
title:  Const相关知识整理
date: 2020-08-30 12:30:03
abbrlink: C-CPP-0000-0002
author: XiaoPb
img: 
coverImg: /medias/banner/10.jpg
top: false
cover: false
toc: true
mathjax: false
summary: 
  Const相关知识整理。
tags:
  - C/C++
  - const
  - make
  - vscode
categories:
  - C/C++
password:
---

# Const相关知识整理

> const是什么？
>
> - const是一个限定符，被它限定的变量值将不能被修改。
> - const是一种约束，由编译器来检查是否有人违反了这个约束

## const关键字的作用

### 1. const的修饰作用

​		const它把一个对象转换成一个只读的常量。它和数据类型及指针符号结合起来，由于顺序不同，转换为常量的对象就出现了差异，是指针的指向不变，还是指向里存的内容不可变，这就是由定义来决定的了。

​		用 const 定义的变量的值是不允许改变的，即不允许给它重新赋值，即使是赋相同的值也不可以。所以说它定义的是只读变量。这也就意味着必须在定义的时候就给它赋初值。如果定义的时候未初始化，我们知道，对于未初始化的局部变量，程序在执行的时候会自动把一个很小的负数存放进去。这样后面再给它赋初值的话就是“改变它的值”了，即发生语法错误。

​		用 const 修饰的变量，无论是全局变量还是局部变量，生存周期都是程序运行的整个过程。全局变量的生存周期为程序运行的整个过程这个是理所当然的。而使用 const 修饰过的局部变量就有了静态特性，它的生存周期也是程序运行的整个过程。我们知道全局变量是静态的，静态的生存周期就是程序运行的整个过程。但是用const修饰过的局部变量只是有了静态特性，并没有说它变成了静态变量。

### 2. const与#define的区别

​		宏定义#define与const的相似点是它可以定义常量。两者的主要差异是#define是编译过程的宏替换，这与const的性质不同。const的只读性质与#define的区别最为突出。

## const修饰变量效果

如下的语句是等价的，也就是说修饰非指针变量时，放在前后效果一样：

```c
const int a = 10;
int const a = 10;
```

## const修饰指针的三种效果，C语言const修饰指针详解

### 1)  const int*p=&a；

同样 const 和 int 可以互换位置，二者是等价的。我们以放在最前面时进行描述。

当把 const 放最前面的时候，它修饰的就是 *p，那么 *p 就不可变。*p 表示的是指针变量 p 所指向的内存单元里面的内容，此时这个内容不可变。其他的都可变，如 p 中存放的是指向的内存单元的地址，这个地址可变，即 p 的指向可变。但指向谁，谁的内容就不可变。

这种用法常见于定义函数的形参。前面学习 printf 和 scanf，以及后面将要学习的很多函数，它们的原型中很多参数都是用 const 修饰的，这样做的好处是安全！我们通过参数传递数据时，就把数据暴露了。而大多数情况下只是想使用传过来的数据，并不想改变它的值，但往往由于编程人员个人水平的原因会不小心改变它的值。这时我们在形参中用 const 把传过来的数据定义成只读的，这样就更安全了。这也是 const 最有用之处。

所以如果你不想改变某个参数传过来的值，那么定义函数时就最好用 const 修饰这个参数，否则就不要用 const 修饰了。

### 2)  int*const p=&a；

此时 const 修饰的是 p，所以 p 中存放的内存单元的地址不可变，而内存单元中的内容可变。即 p 的指向不可变，p 所指向的内存单元的内容可变。

### 3)  const int*const p=&a；

此时 *p 和 p 都被修饰了，那么 p 中存放的内存单元的地址和内存单元中的内容都不可变。

综上所述，使用 const 可以保护用指针访问内存时由指针导致的被访问内存空间中数据的误更改。因为指针是直接访问内存的，没有拷贝，而有些时候使用指针访问内存时并不是要改变里面的值，而只是要使用里面的值，所以一旦不小心误操作把里面的数据改了就糟糕了。

但是这里需要注意的是，上面第 1 种情况中，虽然在 *p 前加上 const 可以禁止指针变量 p 修改变量 a 中的值，但是它只能“禁止指针变量 p 修改”。也就是说，它只能保证在使用指针变量 p 时，p 不能修改 a 中的值。但是我并没有说 const 可以保护 a 禁止一切的修改，其他指向 a 的没有用 const 修饰的指针变量照样可以修改 a 的值，而且变量 a 自己也可以修改自己的值。下面写一个程序看一下：

```c
#include <stdio.h>

int main(void)
{       
    int a = 10;
    int b = 20;
    const int *p1 = &a;
    int *const p2 = &a;
    const int* const p3 = &a;
    printf("%d,%d,%d\r\n",*p1,*p2,*p3);
//  *p1 = 20;  该写法错误,const修饰的是*p1，则*p1不可变
    p1 = &b;
    printf("%d,%d,%d\r\n",*p1,*p2,*p3);
//  p2 = &b;   该写法错误,const修饰的是p2，则p2不可变
    *p2 = 30;
    printf("%d,%d,%d\r\n",*p1,*p2,*p3);
//  p3 = &b;   //该写法错误
//  *p3 = 30;  //该写法错误,const修饰的是*p3和p3，则*p1和p3均不可变
  return 0;
}
```

输出结果是：

```bash
10,10,10
20,10,10
20,30,30
```

#### 1. 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）

#### 2. 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。

#### 3. 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。

### const关键字至少有下列5个作用：

1. 欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
2. 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
3. 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
4. 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
5. 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。

