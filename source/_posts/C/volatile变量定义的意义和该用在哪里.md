---
title:  volatile变量定义的意义和该用在哪里
date: 2020-08-30 12:30:03
abbrlink: C-CPP-0000-0005
author: XiaoPb
img: 
coverImg: /medias/banner/10.jpg
top: false
cover: false
toc: true
mathjax: false
summary: 
  volatile变量定义的意义和该用在哪里。
tags:
  - C/C++
  - volatile
  - make
  - vscode
categories:
  - C/C++
password:

---

# volatile变量定义的意义和该用在哪里

​		一个定义为`volatile`的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是`volatile`变量的几个例子：

1. 并行设备的硬件寄存器（如：状态寄存器）

2. 一个中断服务子程序中会访问到的非自动变量(Non-automati C variables)

3). 多线程应用中被几个任务共享的变量

回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求vola[TI](http://bbs.elecfans.com/zhuti_715_1.html)le变量。不懂得volatile内容将会带来灾难。

假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得`volatile`完全的重要性。

1. 一个参数既可以是`const`还可以是`volatile`吗？解释为什么。

2. 一个指针可以是`volatile` 吗？解释为什么。

3. 下面的函数有什么错误：

```c
int square(volatile int* ptr)
{
	return *ptr * *ptr;
}
```

**下面是答案：**

1. 是的。一个例子是只读的状态寄存器。它是`volatile`因为它可能被意想不到地改变。它是`const`因为程序不应该试图去修改它。

2. 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个`buffer`的指针时。

3. 这段代码的有个恶作剧。这段代码的目的是用来返指针`*ptr`指向值的平方，但是，由于`*ptr`指向一个`volatile`型参数，编译器将产生类似下面的代码：

```c
int square(volatile int *ptr)
{
  int a,b;
  a = *ptr;
  b = *ptr;
  return a * b;
}
```

​		由于`*ptr`的值可能被意想不到地该变，因此`a`和`b`可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：

```c
long square(volatile int *ptr)
{
  int a;
  a = *ptr;
  return a * a;
}
```

​		`volatile`的本意是“易变的”, 由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化。比如：

```c
static int i=0;
int main(void)
{
//  code
  while(1)
  {
    if(i)
      dosomething();
  }
}
/* Interrupt service routine */
void ISR_2(void)
{
  i = 1;
}
```

​		程序的本意是希望`ISR_2`中断产生时，在`main`当中调用`dosomething`函数，但是，由于编译器判断在`main`函数里面没有修改过i，因此 可能只执行一次对从`i`到某寄存器的读操作，然后每次`if`判断都只使用这个寄存器里面的“i副本”，导致`dosomething`永远也不会被调用。如果将将变量加上`volatile`修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。此例中`i`也应该如此说明。

**一般说来，volatile用在如下的几个地方：**

1、中断服务程序中修改的供其它程序检测的变量需要加`volatile`；

2、多任务环境下各任务间共享的标志应该加`volatile`；

3、存储器映射的硬件寄存器通常也要加`volatile`说明，因为每次对它的读写都可能由不同意义；

另外，以上这几种情况经常还要同时考虑数据的完整性（相互关联的几个标志读了一半被打断了重写），在1中可以通过关中断来实

现，2中可以禁止任务调度，3中则只能依靠硬件的良好设计了。

**关键在于两个地方：**

1. 编译器的优化 

   ​		在本次线程内, 当读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中；以后，再取变量值时，就直接从寄存器中取值；当变量值在本线程里改变时，会同时把变量的新值copy到该寄存器中，以便保持一致；当变量在因别的线程等而改变了值，该寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致；当该寄存器在因别的线程等而改变了值，原变量的值不会改变，从而造成应用程序读取的值和实际的变量值不一致。

   举一个不太准确的例子：

   > ​		发薪资时，会计每次都把员工叫来登记他们的银行卡号；一次会计为了省事，没有即时登记，用了以前登记的银行卡号；刚好一个员工的银行卡丢了，已挂失该银行卡号；从而造成该员工领不到工资。
   >
   > ​		员工 －－ 原始变量地址
   >
   > ​		银行卡号 －－ 原始变量在寄存器的备份

2. 在什么情况下会出现(如1楼所说)

   1. 并行设备的硬件寄存器（如：状态寄存器）

   2. 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)

   3. 多线程应用中被几个任务共享的变量

补充： `volatile`应该解释为“直接存取原始内存地址”比较合适，“易变的”这种解释简直有点误导人；“易变”是因为外在因素引起的，像多线程，中断等，并不是因为用`volatile`修饰了的变量就是“易变”了，假如没有外因，即使用`volatile`定义，它也不会变化；而用`volatile`定义之后，其实这个变量就不会因外因而变化了，可以放心使用了； 大家看看前面那种解释（易变的）是不是在误导人。